<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Websocket on 代码如歌</title><link>https://insua.github.io/tags/websocket/</link><description>Recent content in Websocket on 代码如歌</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 17 May 2018 19:59:24 +0000</lastBuildDate><atom:link href="https://insua.github.io/tags/websocket/index.xml" rel="self" type="application/rss+xml"/><item><title>laravel echo server 结合 jwt 授权</title><link>https://insua.github.io/post/2018/05-17-laravel-echo-by-jwt/</link><pubDate>Thu, 17 May 2018 19:59:24 +0000</pubDate><guid>https://insua.github.io/post/2018/05-17-laravel-echo-by-jwt/</guid><description>首先，因为重写了 axios 的拦截器，为了确保 socket 消息头的引入，在 axios 拦截器中中加入
if(window.Echo) { let socketId = window.Echo.socketId() if (socketId) { request.headers.common[&amp;#39;X-Socket-Id&amp;#39;] = socketId } } 然后，修改BroadcastServiceprovider，修改认证路由为api模组
Broadcast::routes([&amp;#34;prefix&amp;#34; =&amp;gt; &amp;#34;api&amp;#34;, &amp;#34;middleware&amp;#34; =&amp;gt; &amp;#34;api&amp;#34;]); 最后，在 laravel-echo-server.json 中确保认证路由的正确
{ &amp;#34;authHost&amp;#34;: &amp;#34;http://dev.test&amp;#34;, &amp;#34;authEndpoint&amp;#34;: &amp;#34;/api/broadcasting/auth&amp;#34; } 同时，在 Laravel Echo中加入token认证
import Cookies from &amp;#39;js-cookie&amp;#39; let token = Cookies.get(&amp;#39;token&amp;#39;) window.Echo = new Echo({ broadcaster: &amp;#39;socket.io&amp;#39;, host: process.env.MIX_ECHO_SERVER, auth: { headers: { &amp;#39;Authorization&amp;#39;: &amp;#39;Bearer &amp;#39; + token } } }) 好了，我们现在可以愉快的使用 laravel 发送广播了，私有频道在 routes/channels.</description></item></channel></rss>