<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>代码如歌</title><link>https://insua.github.io/</link><description>Recent content on 代码如歌</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 09 Nov 2018 11:06:12 +0000</lastBuildDate><atom:link href="https://insua.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>use acme.sh to generate pan-domain ssl</title><link>https://insua.github.io/post/2018/11-09-use-acme-sh-to-generate-pan-domain-ssl/</link><pubDate>Fri, 09 Nov 2018 11:06:12 +0000</pubDate><guid>https://insua.github.io/post/2018/11-09-use-acme-sh-to-generate-pan-domain-ssl/</guid><description>download acme.sh
curl https://get.acme.sh | sh goto acme.sh directory
cd ~/.acme.sh add issued domain
./acme.sh --issue --dns -d &amp;#34;*.domain&amp;#34; --yes-I-know-dns-manual-mode-enough-go-ahead-please add txt dns record
then renew
./acme.sh --issue --dns -d &amp;#34;*.domain&amp;#34; --yes-I-know-dns-manual-mode-enough-go-ahead-please --renew config nginx
ssl_certificate /path/*.domain/fullchain.cer; ssl_certificate_key /path/*.domain/*.domain.key;</description></item><item><title>使用Route macro来定义Route的新方法</title><link>https://insua.github.io/post/2018/11-06-user-route-macro-to-define-new-route-command/</link><pubDate>Tue, 06 Nov 2018 17:43:17 +0000</pubDate><guid>https://insua.github.io/post/2018/11-06-user-route-macro-to-define-new-route-command/</guid><description>使用 Laravel 在做后台表单操作时，通常会增加一个批量删除的功能 起初是在 route 里定义一个新的 delete
Route::delete(&amp;#39;prefix/destroy-selection&amp;#39;, &amp;#39;CurrentController@destroySelection); 之后再定义 apiResource
Route::apiResource(&amp;#39;prefix&amp;#39;, &amp;#39;CurrentController&amp;#39;); 这样写十分啰嗦且冗长，Laravel 的强大之处就是它提供了 Macro 来扩展功能
在 AppServiceProvider 的 boot 方法里加入
Route::macro(&amp;#39;full&amp;#39;,function ($prefix, $controller){ Route::delete($prefix.&amp;#39;/destroy-selection&amp;#39;, $controller.&amp;#39;@destroySelection&amp;#39;)-&amp;gt;name($prefix.&amp;#39;destroy-selection&amp;#39;); Route::apiResource($prefix, $controller); }); 之后在 route 里就可以直接使用 full 来定义了
Route::full(&amp;#39;prefix&amp;#39;, &amp;#39;CurrentController&amp;#39;);</description></item><item><title>如何在 Vue Spa 中使用微信jssdk分享接口</title><link>https://insua.github.io/post/2018/10-09-how-to-use-wechat-jssdk-share-in-vue-spa/</link><pubDate>Tue, 09 Oct 2018 11:44:54 +0000</pubDate><guid>https://insua.github.io/post/2018/10-09-how-to-use-wechat-jssdk-share-in-vue-spa/</guid><description>在Vue Spa项目中，使用了 History 模式，要使用分享接口，只能在第一次访问的时候，就加载jssdk配置，通过Vue router进入其他页面之后再做加载，虽然在调试模式下依然会显示配置正确，但是分享接口是无效的，那么怎么办呢？直接在App.vue下就做jssdk config
实现步骤 编写后端接口 使用了 overture/wechat
public function jssdk(Request $request) { $this-&amp;gt;jssdk-&amp;gt;setUrl($request-&amp;gt;input(&amp;#39;url&amp;#39;)); return $this-&amp;gt;jssdk-&amp;gt;buildConfig([ &amp;#39;onMenuShareAppMessage&amp;#39;, &amp;#39;onMenuShareWechat&amp;#39;, &amp;#39;onMenuShareTimeline&amp;#39;, &amp;#39;getLocation&amp;#39; ], false); } 在App.vue中注入配置 引入wexin-js-sdk
const wx = require(&amp;#39;weixin-js-sdk&amp;#39;) 方法
async getJssdk () { const { data } = await this.$axios.post(&amp;#39;/api/wechat-work/jssdk&amp;#39;, { url: window.location.href }) wx.config(data) } 在分享页面中编写分享方法 引入wexin-js-sdk
const wx = require(&amp;#39;weixin-js-sdk&amp;#39;) 在__mounted__里写入分享方法
wx.ready(() =&amp;gt; { const self = this wx.onMenuShareTimeline({ title: self.shareTitle, link: window.location.href, imgUrl: self.logoPath, success: function () { self.</description></item><item><title>image-webpack-loader resolve jpg file wrong in ubuntu server</title><link>https://insua.github.io/post/2018/08-02-image-webpack-loader-with-jpg-file/</link><pubDate>Thu, 02 Aug 2018 10:35:40 +0000</pubDate><guid>https://insua.github.io/post/2018/08-02-image-webpack-loader-with-jpg-file/</guid><description>In my production Ubuntu server which version is 16.04.3 LTS,after push my code to it,I run
yarn prod but it show me a error notice
ERROR in ./resources/assets/js/mobile/pages/Home/images/banner-oath.jpg Module build failed: Error: write EPIPE at _errnoException (util.js:992:11) at WriteWrap.afterWrite [as oncomplete] (net.js:864:14) after search by google,this link solve my problem
install libpng16-dev in server
sudo apt-get install libpng16-dev then, it is all fine.</description></item><item><title>laravel echo server 结合 jwt 授权</title><link>https://insua.github.io/post/2018/05-17-laravel-echo-by-jwt/</link><pubDate>Thu, 17 May 2018 19:59:24 +0000</pubDate><guid>https://insua.github.io/post/2018/05-17-laravel-echo-by-jwt/</guid><description>首先，因为重写了 axios 的拦截器，为了确保 socket 消息头的引入，在 axios 拦截器中中加入
if(window.Echo) { let socketId = window.Echo.socketId() if (socketId) { request.headers.common[&amp;#39;X-Socket-Id&amp;#39;] = socketId } } 然后，修改BroadcastServiceprovider，修改认证路由为api模组
Broadcast::routes([&amp;#34;prefix&amp;#34; =&amp;gt; &amp;#34;api&amp;#34;, &amp;#34;middleware&amp;#34; =&amp;gt; &amp;#34;api&amp;#34;]); 最后，在 laravel-echo-server.json 中确保认证路由的正确
{ &amp;#34;authHost&amp;#34;: &amp;#34;http://dev.test&amp;#34;, &amp;#34;authEndpoint&amp;#34;: &amp;#34;/api/broadcasting/auth&amp;#34; } 同时，在 Laravel Echo中加入token认证
import Cookies from &amp;#39;js-cookie&amp;#39; let token = Cookies.get(&amp;#39;token&amp;#39;) window.Echo = new Echo({ broadcaster: &amp;#39;socket.io&amp;#39;, host: process.env.MIX_ECHO_SERVER, auth: { headers: { &amp;#39;Authorization&amp;#39;: &amp;#39;Bearer &amp;#39; + token } } }) 好了，我们现在可以愉快的使用 laravel 发送广播了，私有频道在 routes/channels.</description></item><item><title>使用Sortable.js和Vue.Draggable的一些坑</title><link>https://insua.github.io/post/2018/05-17-use-vue-draggable-and-sortable-js/</link><pubDate>Thu, 17 May 2018 17:55:47 +0000</pubDate><guid>https://insua.github.io/post/2018/05-17-use-vue-draggable-and-sortable-js/</guid><description>Sortable.js 是拖拽列表最著名的库，而 Vue.Draggable 是其在 Vue 中的封装，在 vue 中引入十分的方便。
但是我在项目中的需求是左侧列表初始时是空的，从右侧列表拖动到左侧生成，这就造成了一个问题，左侧因为没有dom节点而拖不过来，这时就需要在左侧的 draggable 组件添加一个 min-height 的 css 属性。
另一个问题是，在使用 clone 模式时，因为 js 对象都是指向同一个指针的，再从右侧拖动到左侧的节点，当修改其属性时，把所有拖拽过来的相同节点也都修改了。
我的解决方法是，把右侧改为 pull 模式，同时使用 vue 的 watch，当右侧的列表发生变化时重新生成，这样就和初始化的对象完全脱离了。</description></item><item><title>在vue中使用viewerjs</title><link>https://insua.github.io/post/2018/04-22-use-viewerjs-in-vue/</link><pubDate>Sun, 22 Apr 2018 08:49:17 +0000</pubDate><guid>https://insua.github.io/post/2018/04-22-use-viewerjs-in-vue/</guid><description>在 vue中使用viewerjs 必须执行 viewer.update
const viewer = new Viewer(this.$refs.image) this.$nextTick().then(() =&amp;gt; { viewer.update() }) viewer.view(0) 当然最后别忘了引入css
@import &amp;#34;~viewerjs/dist/viewer.css&amp;#34;;</description></item><item><title>Laravel Elixir使用webpack打包只引入moment.js的中文语言包</title><link>https://insua.github.io/post/2018/02-08-thin-moment-js-in-laravel-elixir/</link><pubDate>Thu, 08 Feb 2018 09:21:58 +0000</pubDate><guid>https://insua.github.io/post/2018/02-08-thin-moment-js-in-laravel-elixir/</guid><description>方法是使用webpack内置的ContextReplacementPlugin插件
修改_gulpfile.js_
先引入webpack
const webpack = require(&amp;#39;webpack&amp;#39;) 增加自定义webpack配置
elixir(mix =&amp;gt; { Elixir.webpack.mergeConfig({ plugins: [ new webpack.ContextReplacementPlugin(/moment[\\/]locale$/, /^\.\/(zh-cn)$/) ] }); 之后运行
gulp 会发现打包之后的js会明显变小</description></item><item><title>Laravel 执行定时任务时的url域名</title><link>https://insua.github.io/post/2018/01-30-laravel-console-domain/</link><pubDate>Tue, 30 Jan 2018 22:22:30 +0000</pubDate><guid>https://insua.github.io/post/2018/01-30-laravel-console-domain/</guid><description>在laravel开发时，我最常用的url函数是route，因为根据route函数生成的url如果命名路由写错了那么直接会报错，这样有问题能早发现。 在生成定时任务的时候，在console里，我也写了route，但是推送到用户的地址却是localhost，这可太奇怪了，于是翻了laravel的源代码
laravel/framework/src/Illuminate/Foundation/Bootstrap/SetRequestForConsole.php
public function bootstrap(Application $app) { $url = $app-&amp;gt;make(&amp;#39;config&amp;#39;)-&amp;gt;get(&amp;#39;app.url&amp;#39;, &amp;#39;http://localhost&amp;#39;); $app-&amp;gt;instance(&amp;#39;request&amp;#39;, Request::create($url, &amp;#39;GET&amp;#39;, [], [], [], $_SERVER)); } 原来是因为走定时器任务时是在命令行里执行的，laravel无法根据用户的输入而得到域名，那么就必须读取配置文件了 当然在 .env里定义是最佳实践了</description></item><item><title>用wakatime来统计coding信息</title><link>https://insua.github.io/post/2017/09-06-use-wakatime-to-statistics-coding-time/</link><pubDate>Wed, 06 Sep 2017 20:38:46 +0000</pubDate><guid>https://insua.github.io/post/2017/09-06-use-wakatime-to-statistics-coding-time/</guid><description>wakatime的主页
目前支持绝大部分主流的编辑器和IDE 我把phpstorm、vim、datagrip、sublime和zsh都装上了wakatime的插件
装完了之后，就啥也不用管了，wakatime会自动把你的coding信息传到他的服务器，然后做成漂亮的图表来展示 他还有一个coding time的排行榜 蛤，我在哪？ 每个人的主页上，会详细展示语言、编辑器和操作系统使用时间的百分比 比如 我的主页</description></item><item><title>在Arch上使用Laravel valet</title><link>https://insua.github.io/post/2017/05-13-install-valet-on-arch/</link><pubDate>Sat, 13 May 2017 10:22:57 +0000</pubDate><guid>https://insua.github.io/post/2017/05-13-install-valet-on-arch/</guid><description>valet-linux的github地址
valet默认是使用NetWorkManager来管理dnsmasq的，不过我是用netctl来管理网络的，所以默认安装后ping foo.app并不能指向127.0.0.1
那么就直接用dnsmasq了
$ sudo vim /etc/dnsmasq.conf 修改listen-address和address
listen-address=127.0.0.1 address=/app/127.0.0.1 address=/dev/192.168.10.10 指向dev的是homestead的ip,valet的默认domain修改为app
修改 /etc/resolv.conf 将
nameserver 127.0.0.1 加到最上面
使用
$ sudo chattr +i /etc/resolv.conf 为其加锁，最后别忘了用systemd将dnsmasq自动启动
$ sudo systemctl enable dnsmasq valet-linux其他的使用按照github wiki上的操作即可，目前没有发现什么异常</description></item><item><title>一些gitlab的tips</title><link>https://insua.github.io/post/2017/03-10-some-gitlab-tips/</link><pubDate>Fri, 10 Mar 2017 20:53:45 +0000</pubDate><guid>https://insua.github.io/post/2017/03-10-some-gitlab-tips/</guid><description>Tips1: 禁止登录
登录服务器修改数据库
$ sudo -u gitlab-psql /opt/gitlab/embedded/bin/psql -h /var/opt/gitlab/postgresql gitlabhq_production update application_settings set signin_enabled=true; Tips2: 忘记密码 登录服务器，进入console修改
$ sudo gitlab-rails console production user = User.find(1) user.password = &amp;#34;xxxxx&amp;#34; user.save</description></item><item><title>AUR打包成pkg</title><link>https://insua.github.io/post/2017/02-05-arch-make-pkg/</link><pubDate>Sun, 05 Feb 2017 20:40:15 +0000</pubDate><guid>https://insua.github.io/post/2017/02-05-arch-make-pkg/</guid><description>大多数情况下，我们都是使用yaourt等AUR包管理工具来安装、更新AUR包，不过有些时候在网络条件比较差的情况下，源文件下载特别慢而build失败，我们先把PKGBUILD下载到本地
$ yaourt -G pkg-name $ cd pkg-name 查看PKGBUILD
$ vim PKGBUILD 在找到源码的地址后，可以使用下载工具将源码下载或克隆到本地，修改源码地址，之后编译生成pkg包
$ makepkg 编译、打包完成后，在目录下会生成pkg-name-version-arch.pkg.tar.xz
直接安装到本机的话，执行命令
$ sudo pacman -U pkg-name-version-arch.pkg.tar.xz</description></item><item><title>开发Laravel时必备的三个包</title><link>https://insua.github.io/post/2017/01-17-three-packages-for-laravel-developer/</link><pubDate>Tue, 17 Jan 2017 21:16:46 +0000</pubDate><guid>https://insua.github.io/post/2017/01-17-three-packages-for-laravel-developer/</guid><description>barryvdh/laravel-debugbar 作用是页面底部显示丰富的调试信息
安装
$ composer require barryvdh/laravel-debugbar config/app.php注册ServerProvider
Barryvdh\Debugbar\ServiceProvider::class, 增加Facades
&amp;#39;Debugbar&amp;#39; =&amp;gt; Barryvdh\Debugbar\Facade::class, barryvdh/laravel-ide-helper 生成一个php文件，为IDE提供更好的支持
安装
$ composer require barryvdh/laravel-ide-helper config/app.php注册ServerProvider
Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider::class, 使用
如果使用的是Homestead，ssh登录虚拟机后，在虚拟机执行，否则会找不到数据库而报错
sven/artisan-view 使用artisan命令生成视图文件
安装
$ composer require sven/artisan-view config/app.php注册ServerProvider
Sven\ArtisanView\ArtisanViewServiceProvider::class, 使用
生成视图
$ php artisan make:view index 生成目录下的视图
$ php artisan make:view pages.index</description></item></channel></rss>